/*
 * Project: nexd 
 * Copyright (C) 2004  Manuel Pichler <manuel.pichler@xplib.de>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

/*
 * $Log: DocumentTypeImpl.java,v $
 * Revision 1.2  2005/05/11 17:31:39  nexd
 * Refactoring and extended test cases
 *
 * Revision 1.1  2005/05/08 11:59:31  nexd
 * restructuring
 *
 * Revision 1.7  2005/04/24 15:00:26  nexd
 * Bugfixes and many performance and coding improvements.
 *
 * Revision 1.6  2005/03/31 12:08:39  nexd
 * Advanced VCL support
 *
 * Revision 1.5  2005/03/14 12:22:48  nexd
 * Heavy javadoc, checkstyle and eclipse todo-Task session.
 *
 */
package de.xplib.nexd.engine.xml.dom;

import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;

import de.xplib.nexd.xml.DOMDocumentTypeI;

/**
 * 
 * Each <code>Document</code> has a <code>doctype</code> attribute whose value 
 * is either <code>null</code> or a <code>DocumentType</code> object. The 
 * <code>DocumentType</code> interface in the DOM Core provides an interface 
 * to the list of entities that are defined for the document, and little 
 * else because the effect of namespaces and the various XML schema efforts 
 * on DTD representation are not clearly understood as of this writing.
 * <p>DOM Level 3 doesn't support editing <code>DocumentType</code> nodes. 
 * <code>DocumentType</code> nodes are read-only.
 * <p>See also the <a 
 * href='http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407'
 * >Document Object Model (DOM) Level 3 Core Specification</a>.
 *  
 * @author Manuel Pichler <manuel.pichler@xplib.de>
 * @version $Rev$
 */
public class DocumentTypeImpl extends AbstractNode implements DOMDocumentTypeI {
    
    /**
     * Empty node map for not used methods.
     */
    private static final NamedNodeMap NODE_MAP = new NamedNodeMapImpl(null);
    
    /**
     * The public id of the DTD.
     */
    private final String publicId;
    
    /**
     * The system id of the DTD.
     */
    private final String systemId;
    
    /**
     * Comment for <code>subset</code>
     */
    private String subset = "";
    
    /**
     * Constructor.
     * 
     * @param qualifiedNameIn The name of the root <code>Element</code>.
     * @param publicIdIn The public id of the DTD.
     * @param systemIdIn The system id of the DTD.
     */
    protected DocumentTypeImpl(final String qualifiedNameIn,
                               final String publicIdIn,
                               final String systemIdIn) {
        
        super(null, qualifiedNameIn, Node.DOCUMENT_TYPE_NODE);
        
        this.publicId = publicIdIn;
        this.systemId = systemIdIn;
    }

    /**
     * Returns a duplicate of this node, i.e., serves as a generic copy 
     * constructor for nodes. The duplicate node has no parent; (
     * <code>parentNode</code> is <code>null</code>.) and no user data. User 
     * data associated to the imported node is not carried over. However, if 
     * any <code>UserDataHandlers</code> has been specified along with the 
     * associated data these handlers will be called with the appropriate 
     * parameters before this method returns.
     * <br>Cloning an <code>Element</code> copies all attributes and their 
     * values, including those generated by the XML processor to represent 
     * defaulted attributes, but this method does not copy any children it 
     * contains unless it is a deep clone. This includes text contained in 
     * an the <code>Element</code> since the text is contained in a child 
     * <code>Text</code> node. Cloning an <code>Attribute</code> directly, 
     * as opposed to be cloned as part of an <code>Element</code> cloning 
     * operation, returns a specified attribute (<code>specified</code> is 
     * <code>true</code>). Cloning an <code>Attribute</code> always clones 
     * its children, since they represent its value, no matter whether this 
     * is a deep clone or not. Cloning an <code>EntityReference</code> 
     * automatically constructs its subtree if a corresponding 
     * <code>Entity</code> is available, no matter whether this is a deep 
     * clone or not. Cloning any other type of node simply returns a copy of 
     * this node.
     * <br>Note that cloning an immutable subtree results in a mutable copy, 
     * but the children of an <code>EntityReference</code> clone are readonly
     * . In addition, clones of unspecified <code>Attr</code> nodes are 
     * specified. And, cloning <code>Document</code>, 
     * <code>DocumentType</code>, <code>Entity</code>, and 
     * <code>Notation</code> nodes is implementation dependent.
     * 
     * @param deep If <code>true</code>, recursively clone the subtree under 
     *   the specified node; if <code>false</code>, clone only the node 
     *   itself (and its attributes, if it is an <code>Element</code>).
     * @return The duplicate node.
     * @see org.w3c.dom.Node#cloneNode(boolean)
     */
    public Node cloneNode(final boolean deep) {
        DocumentTypeImpl clone = new DocumentTypeImpl(
                this.getName(), this.publicId, this.systemId);
        clone.setInternalSubset(this.subset);
            
        return clone;
    }

    /**
     * The name of DTD; i.e., the name immediately following the 
     * <code>DOCTYPE</code> keyword.
     * 
     * @return The name of the root <code>Element</code> same as 
     *         <code>getNodeName</code>.
     * @see org.w3c.dom.DocumentType#getName()
     */
    public String getName() {
        return this.getNodeName();
    }

    /**
     * A <code>NamedNodeMap</code> containing the general entities, both 
     * external and internal, declared in the DTD. Parameter entities are 
     * not contained. Duplicates are discarded. For example in: 
     * <pre>&lt;!DOCTYPE 
     * ex SYSTEM "ex.dtd" [ &lt;!ENTITY foo "foo"&gt; &lt;!ENTITY bar 
     * "bar"&gt; &lt;!ENTITY bar "bar2"&gt; &lt;!ENTITY % baz "baz"&gt; 
     * ]&gt; &lt;ex/&gt;</pre>
     *  the interface provides access to <code>foo</code> 
     * and the first declaration of <code>bar</code> but not the second 
     * declaration of <code>bar</code> or <code>baz</code>. Every node in 
     * this map also implements the <code>Entity</code> interface.
     * <br>The DOM Level 2 does not support editing entities, therefore 
     * <code>entities</code> cannot be altered in any way.
     * 
     * @return
     * @see org.w3c.dom.DocumentType#getEntities()
     */
    public NamedNodeMap getEntities() {
        return NODE_MAP;
    }

    /**
     * A <code>NamedNodeMap</code> containing the notations declared in the 
     * DTD. Duplicates are discarded. Every node in this map also implements 
     * the <code>Notation</code> interface.
     * <br>The DOM Level 2 does not support editing notations, therefore 
     * <code>notations</code> cannot be altered in any way.
     * 
     * @return
     * @see org.w3c.dom.DocumentType#getNotations()
     */
    public NamedNodeMap getNotations() {
        return NODE_MAP;
    }

    /**
     * The public identifier of the external subset.
     * 
     * @since DOM Level 2
     * @return The public identifier.
     * @see org.w3c.dom.DocumentType#getPublicId()
     */
    public String getPublicId() {
        return this.publicId;
    }

    /**
     * The system identifier of the external subset. This may be an absolute 
     * URI or not.
     * 
     * @since DOM Level 2
     * @return The system identifier.
     * @see org.w3c.dom.DocumentType#getSystemId()
     */
    public String getSystemId() {
        return this.systemId;
    }

    /**
     * The internal subset as a string, or <code>null</code> if there is none. 
     * This is does not contain the delimiting square brackets.
     * <p ><b>Note:</b> The actual content returned depends on how much 
     * information is available to the implementation. This may vary 
     * depending on various parameters, including the XML processor used to 
     * build the document.
     * 
     * @since DOM Level 2
     * @return
     * @see org.w3c.dom.DocumentType#getInternalSubset()
     */
    public String getInternalSubset() {
        return this.subset;
    }
    
    //
    // Non standard methods
    //
    
    /**
     * Setter method for the internal subset.
     * 
     * @param subsetIn The internal subset.
     */
    public void setInternalSubset(final String subsetIn) {
        this.subset = subsetIn;
    }
    
    /**
     * Adds a comment to the internal subset.
     * 
     * @param commentIn The content of a comment.
     */
    public void addComment(final String commentIn) {
       this.subset += "<!--" + commentIn + "-->\n"; 
    }
    
    /**
     * Adds an element declaration to the internal subset.
     * 
     * @param nameIn The element name.
     * @param modelIn The element model.
     */
    public void addElement(final String nameIn, final String modelIn) {
        this.subset += "<!ELEMENT " + nameIn + " " + modelIn + ">\n";
    }
    
    /**
     * @param eNameIn The element name.
     * @param aNameIn The attribute name.
     * @param typeIn The attribute type.
     * @param modeIn The attribute default mode.
     * @param valueIn The attribute default value.
     */
    public void addAttribute(final String eNameIn, 
                             final String aNameIn,
                             final String typeIn,
                             final String modeIn,
                             final String valueIn) {
        
        String attr = "<!ATTLIST " + eNameIn + " " + aNameIn 
                    + " " + typeIn;
        if (modeIn != null) {
            attr += " " + modeIn;
        }
        if (valueIn != null) {
            attr += " \"" + valueIn + "\"";
        }
        attr += ">\n";
        
        this.subset += attr;
    }
    
    /**
     * Adds an internal entity declaration to the internal subset.
     * 
     * @param nameIn The entity name.
     * @param valueIn The entity value.
     */
    public void addInternalEntityDecl(final String nameIn, 
                                      final String valueIn) {
        String entity = "<!ENTITY " + nameIn.substring(0, 1) + " "
                      + nameIn.substring(1) + " \"" + valueIn + "\">\n";
        this.subset += entity;
    }

}
