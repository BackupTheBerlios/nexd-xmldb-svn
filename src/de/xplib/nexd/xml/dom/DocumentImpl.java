/*
 * Project: nexd 
 * Copyright (C) 2004  Manuel Pichler <manuel.pichler@xplib.de>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package de.xplib.nexd.xml.dom;

import org.w3c.dom.Attr;
import org.w3c.dom.CDATASection;
import org.w3c.dom.Comment;
import org.w3c.dom.DOMConfiguration;
import org.w3c.dom.DOMErrorHandler;
import org.w3c.dom.DOMException;
import org.w3c.dom.DOMImplementation;
import org.w3c.dom.Document;
import org.w3c.dom.DocumentFragment;
import org.w3c.dom.DocumentType;
import org.w3c.dom.Element;
import org.w3c.dom.EntityReference;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.ProcessingInstruction;
import org.w3c.dom.Text;

/**
 * The <code>Document</code> interface represents the entire HTML or XML 
 * document. Conceptually, it is the root of the document tree, and provides 
 * the primary access to the document's data.
 * <p>Since elements, text nodes, comments, processing instructions, etc. 
 * cannot exist outside the context of a <code>Document</code>, the 
 * <code>Document</code> interface also contains the factory methods needed 
 * to create these objects. The <code>Node</code> objects created have a 
 * <code>ownerDocument</code> attribute which associates them with the 
 * <code>Document</code> within whose context they were created.
 * <p>See also the <a 
 * href='http://www.w3.org/TR/2002/WD-DOM-Level-3-Core-20020114'
 * >Document Object Model (DOM) Level 3 Core Specification</a>.
 *  
 * @author Manuel Pichler <manuel.pichler@xplib.de>
 * @version $Rev$
 */
public class DocumentImpl extends AbstractParentNode implements Document {
    
    /**
     * Comment for <code>documentElement</code>
     */
    private ElementImpl documentElement = null;
    
    /**
     * Comment for <code>doctype</code>
     */
    private DocumentTypeImpl doctype = null;
    
    /**
     * Comment for <code>domImpl</code>
     */
    private DOMImplementationImpl domImpl = null;
    
    /**
     * Comment for <code>standalone</code>
     */
    private boolean standalone = false;
    
    /**
     * Comment for <code>version</code>
     */
    private String version = "1.0";

    /**
     * @param domImplIn ..
     */
    protected DocumentImpl(final DOMImplementationImpl domImplIn) {
        super(null, "#document", Node.DOCUMENT_NODE);
        
        this.domImpl = domImplIn;
    }

    /**
     * Returns a duplicate of this node, i.e., serves as a generic copy 
     * constructor for nodes. The duplicate node has no parent; (
     * <code>parentNode</code> is <code>null</code>.) and no user data. User 
     * data associated to the imported node is not carried over. However, if 
     * any <code>UserDataHandlers</code> has been specified along with the 
     * associated data these handlers will be called with the appropriate 
     * parameters before this method returns.
     * <br>Cloning an <code>Element</code> copies all attributes and their 
     * values, including those generated by the XML processor to represent 
     * defaulted attributes, but this method does not copy any children it 
     * contains unless it is a deep clone. This includes text contained in 
     * an the <code>Element</code> since the text is contained in a child 
     * <code>Text</code> node. Cloning an <code>Attribute</code> directly, 
     * as opposed to be cloned as part of an <code>Element</code> cloning 
     * operation, returns a specified attribute (<code>specified</code> is 
     * <code>true</code>). Cloning an <code>Attribute</code> always clones 
     * its children, since they represent its value, no matter whether this 
     * is a deep clone or not. Cloning an <code>EntityReference</code> 
     * automatically constructs its subtree if a corresponding 
     * <code>Entity</code> is available, no matter whether this is a deep 
     * clone or not. Cloning any other type of node simply returns a copy of 
     * this node.
     * <br>Note that cloning an immutable subtree results in a mutable copy, 
     * but the children of an <code>EntityReference</code> clone are readonly
     * . In addition, clones of unspecified <code>Attr</code> nodes are 
     * specified. And, cloning <code>Document</code>, 
     * <code>DocumentType</code>, <code>Entity</code>, and 
     * <code>Notation</code> nodes is implementation dependent.
     * 
     * @param deep If <code>true</code>, recursively clone the subtree under 
     *   the specified node; if <code>false</code>, clone only the node 
     *   itself (and its attributes, if it is an <code>Element</code>).
     * @return The duplicate node.
     * @see org.w3c.dom.Node#cloneNode(boolean)
     */
    public Node cloneNode(final boolean deep) {
        // TODO : Auto-generated method stub
        return null;
    }

    /**
     * The Document Type Declaration (see <code>DocumentType</code>) 
     * associated with this document. For HTML documents as well as XML 
     * documents without a document type declaration this returns 
     * <code>null</code>. The DOM Level 2 does not support editing the 
     * Document Type Declaration.
     * 
     * @return ---
     * @version DOM Level 3
     * @see org.w3c.dom.Document#getDoctype()
     */
    public DocumentType getDoctype() {
        return this.doctype;
    } // end public DocumentType getDoctype()

    /**
     * The <code>DOMImplementation</code> object that handles this document. A 
     * DOM application may use objects from multiple implementations.
     * 
     * @return ---
     * @see org.w3c.dom.Document#getImplementation()
     */
    public DOMImplementation getImplementation() {
        return this.domImpl;
    }

    /**
     * This is a convenience attribute that allows direct access to the child 
     * node that is the document element of the document.
     * <br> This attribute represents the property [document element] defined 
     * in . 
     * 
     * @return ---
     * @see org.w3c.dom.Document#getDocumentElement()
     */
    public Element getDocumentElement() {
        return this.documentElement;
    }

    /**
     * Creates an element of the type specified. Note that the instance 
     * returned implements the <code>Element</code> interface, so attributes 
     * can be specified directly on the returned object.
     * <br>In addition, if there are known attributes with default values, 
     * <code>Attr</code> nodes representing them are automatically created 
     * and attached to the element.
     * <br>To create an element with a qualified name and namespace URI, use 
     * the <code>createElementNS</code> method.
     * 
     * @param tagName The name of the element type to instantiate. For XML, 
     *   this is case-sensitive, otherwise it depends on the case-sentivity 
     *   of the markup language in use. In that case, the name is mapped to 
     *   the canonical form of that markup by the DOM implementation.
     * @return A new <code>Element</code> object with the 
     *   <code>nodeName</code> attribute set to <code>tagName</code>, and 
     *   <code>localName</code>, <code>prefix</code>, and 
     *   <code>namespaceURI</code> set to <code>null</code>.
     * @exception DOMException
     *   INVALID_CHARACTER_ERR: Raised if the specified name contains an 
     *   illegal character.
     * @see org.w3c.dom.Document#createElement(java.lang.String)
     */
    public Element createElement(final String tagName) throws DOMException {
        return new ElementImpl(this, tagName);
    }

    /**
     * Creates an empty <code>DocumentFragment</code> object.
     * @return A new <code>DocumentFragment</code>.
     * @see org.w3c.dom.Document#createDocumentFragment()
     */
    public DocumentFragment createDocumentFragment() {
        // TODO Auto-generated method stub
        return null;
    }

    /**
     * Creates a <code>Text</code> node given the specified string.
     * @param data The data for the node.
     * @return The new <code>Text</code> object.
     * @see org.w3c.dom.Document#createTextNode(java.lang.String)
     */
    public Text createTextNode(final String data) {
        return new TextImpl(this, data);
    }

    /**
     * Creates a <code>Comment</code> node given the specified string.
     * @param data The data for the node.
     * @return The new <code>Comment</code> object.
     * @see org.w3c.dom.Document#createComment(java.lang.String)
     */
    public Comment createComment(final String data) {
        return new CommentImpl(this, data);
    }

    /**
     * Creates a <code>CDATASection</code> node whose value is the specified 
     * string.
     * 
     * @param data The data for the <code>CDATASection</code> contents.
     * @return The new <code>CDATASection</code> object.
     * @exception DOMException
     *   NOT_SUPPORTED_ERR: Raised if this document is an HTML document.
     * @see org.w3c.dom.Document#createCDATASection(java.lang.String)
     */
    public CDATASection createCDATASection(final String data) 
    		throws DOMException {
        
        return new CDATASectionImpl(this, data);
    }

    /**
     * Creates a <code>ProcessingInstruction</code> node given the specified 
     * name and data strings.
     * 
     * @param target The target part of the processing instruction.
     * @param data The data for the node.
     * @return The new <code>ProcessingInstruction</code> object.
     * @exception DOMException
     *   INVALID_CHARACTER_ERR: Raised if the specified target contains an 
     *   illegal character.
     *   <br>NOT_SUPPORTED_ERR: Raised if this document is an HTML document.
     * @see org.w3c.dom.Document#createProcessingInstruction(
     * 		java.lang.String, java.lang.String)
     */
    public ProcessingInstruction createProcessingInstruction(
            final String target,
            final String data) throws DOMException {

        return new ProcessingInstructionImpl(this, target, data);
    }

    /**
     * Creates an <code>Attr</code> of the given name. Note that the 
     * <code>Attr</code> instance can then be set on an <code>Element</code> 
     * using the <code>setAttributeNode</code> method. 
     * <br>To create an attribute with a qualified name and namespace URI, use 
     * the <code>createAttributeNS</code> method.
     * 
     * @param name The name of the attribute.
     * @return A new <code>Attr</code> object with the <code>nodeName</code> 
     *   attribute set to <code>name</code>, and <code>localName</code>, 
     *   <code>prefix</code>, and <code>namespaceURI</code> set to 
     *   <code>null</code>. The value of the attribute is the empty string.
     * @exception DOMException
     *   INVALID_CHARACTER_ERR: Raised if the specified name contains an 
     *   illegal character.
     * @see org.w3c.dom.Document#createAttribute(java.lang.String)
     */
    public Attr createAttribute(final String name) throws DOMException {
        return new AttrImpl(this, name);
    }

    /**
     * Creates an <code>EntityReference</code> object. In addition, if the 
     * referenced entity is known, the child list of the 
     * <code>EntityReference</code> node is made the same as that of the 
     * corresponding <code>Entity</code> node.If any descendant of the 
     * <code>Entity</code> node has an unbound namespace prefix, the 
     * corresponding descendant of the created <code>EntityReference</code> 
     * node is also unbound; (its <code>namespaceURI</code> is 
     * <code>null</code>). The DOM Level 2 does not support any mechanism to 
     * resolve namespace prefixes.
     * 
     * @param name The name of the entity to reference.
     * @return The new <code>EntityReference</code> object.
     * @exception DOMException
     *   INVALID_CHARACTER_ERR: Raised if the specified name contains an 
     *   illegal character.
     *   <br>NOT_SUPPORTED_ERR: Raised if this document is an HTML document.
     * @see org.w3c.dom.Document#createEntityReference(java.lang.String)
     */
    public EntityReference createEntityReference(final String name)
            throws DOMException {
        // TODO Auto-generated method stub
        return null;
    }

    /**
     * Returns a <code>NodeList</code> of all the <code>Elements</code> with a 
     * given tag name in document order.
     * 
     * @param tagname The name of the tag to match on. The special value "*" 
     *   matches all tags. For XML, this is case-sensitive, otherwise it 
     *   depends on the case-sentivity of the markup language in use.
     * @return A new <code>NodeList</code> object containing all the matched 
     *   <code>Elements</code>.
     * @see org.w3c.dom.Document#getElementsByTagName(java.lang.String)
     */
    public NodeList getElementsByTagName(final String tagname) {
        
        if (this.documentElement == null) {
            return new NodeListImpl(this);
        }
        
        NodeListImpl nodeList = (NodeListImpl) 
        		this.documentElement.getElementsByTagName(tagname);
        
        if (tagname.equals("*") 
            || this.documentElement.getTagName().equals(tagname)) {
            
            nodeList.getList().add(0, this.documentElement);
        }
        return nodeList;
    }

    /**
     * Imports a node from another document to this document. The returned 
     * node has no parent; (<code>parentNode</code> is <code>null</code>). 
     * The source node is not altered or removed from the original document; 
     * this method creates a new copy of the source node.
     * <br>For all nodes, importing a node creates a node object owned by the 
     * importing document, with attribute values identical to the source 
     * node's <code>nodeName</code> and <code>nodeType</code>, plus the 
     * attributes related to namespaces (<code>prefix</code>, 
     * <code>localName</code>, and <code>namespaceURI</code>). As in the 
     * <code>cloneNode</code> operation, the source node is not altered. 
     * User data associated to the imported node is not carried over. 
     * However, if any <code>UserDataHandlers</code> has been specified 
     * along with the associated data these handlers will be called with the 
     * appropriate parameters before this method returns.
     * <br>Additional information is copied as appropriate to the 
     * <code>nodeType</code>, attempting to mirror the behavior expected if 
     * a fragment of XML or HTML source was copied from one document to 
     * another, recognizing that the two documents may have different DTDs 
     * in the XML case. The following list describes the specifics for each 
     * type of node. 
     * <dl>
     * <dt>ATTRIBUTE_NODE</dt>
     * <dd>The <code>ownerElement</code> attribute 
     * is set to <code>null</code> and the <code>specified</code> flag is 
     * set to <code>true</code> on the generated <code>Attr</code>. The 
     * descendants of the source <code>Attr</code> are recursively imported 
     * and the resulting nodes reassembled to form the corresponding subtree.
     * Note that the <code>deep</code> parameter has no effect on 
     * <code>Attr</code> nodes; they always carry their children with them 
     * when imported.</dd>
     * <dt>DOCUMENT_FRAGMENT_NODE</dt>
     * <dd>If the <code>deep</code> option 
     * was set to <code>true</code>, the descendants of the source 
     * <code>DocumentFragment</code> are recursively imported and the 
     * resulting nodes reassembled under the imported 
     * <code>DocumentFragment</code> to form the corresponding subtree. 
     * Otherwise, this simply generates an empty 
     * <code>DocumentFragment</code>.</dd>
     * <dt>DOCUMENT_NODE</dt>
     * <dd><code>Document</code> 
     * nodes cannot be imported.</dd>
     * <dt>DOCUMENT_TYPE_NODE</dt>
     * <dd><code>DocumentType</code> 
     * nodes cannot be imported.</dd>
     * <dt>ELEMENT_NODE</dt>
     * <dd>Specified attribute nodes of the 
     * source element are imported, and the generated <code>Attr</code> 
     * nodes are attached to the generated <code>Element</code>. Default 
     * attributes are not copied, though if the document being imported into 
     * defines default attributes for this element name, those are assigned. 
     * If the <code>importNode</code> <code>deep</code> parameter was set to 
     * <code>true</code>, the descendants of the source element are 
     * recursively imported and the resulting nodes reassembled to form the 
     * corresponding subtree.</dd>
     * <dt>ENTITY_NODE</dt>
     * <dd><code>Entity</code> nodes can be 
     * imported, however in the current release of the DOM the 
     * <code>DocumentType</code> is readonly. Ability to add these imported 
     * nodes to a <code>DocumentType</code> will be considered for addition 
     * to a future release of the DOM.On import, the <code>publicId</code>, 
     * <code>systemId</code>, and <code>notationName</code> attributes are 
     * copied. If a <code>deep</code> import is requested, the descendants 
     * of the the source <code>Entity</code> are recursively imported and 
     * the resulting nodes reassembled to form the corresponding subtree.</dd>
     * <dt>
     * ENTITY_REFERENCE_NODE</dt>
     * <dd>Only the <code>EntityReference</code> itself is 
     * copied, even if a <code>deep</code> import is requested, since the 
     * source and destination documents might have defined the entity 
     * differently. If the document being imported into provides a 
     * definition for this entity name, its value is assigned.</dd>
     * <dt>NOTATION_NODE</dt>
     * <dd>
     * <code>Notation</code> nodes can be imported, however in the current 
     * release of the DOM the <code>DocumentType</code> is readonly. Ability 
     * to add these imported nodes to a <code>DocumentType</code> will be 
     * considered for addition to a future release of the DOM.On import, the 
     * <code>publicId</code> and <code>systemId</code> attributes are copied.
     * Note that the <code>deep</code> parameter has no effect on this type 
     * of nodes since they cannot have any children.</dd>
     * <dt>
     * PROCESSING_INSTRUCTION_NODE</dt>
     * <dd>The imported node copies its 
     * <code>target</code> and <code>data</code> values from those of the 
     * source node.Note that the <code>deep</code> parameter has no effect 
     * on this type of nodes since they cannot have any children.</dd>
     * <dt>TEXT_NODE, 
     * CDATA_SECTION_NODE, COMMENT_NODE</dt>
     * <dd>These three types of nodes inheriting 
     * from <code>CharacterData</code> copy their <code>data</code> and 
     * <code>length</code> attributes from those of the source node.Note 
     * that the <code>deep</code> parameter has no effect on these types of 
     * nodes since they cannot have any children.</dd>
     * </dl> 
     * 
     * @param importedNode The node to import.
     * @param deep If <code>true</code>, recursively import the subtree under 
     *   the specified node; if <code>false</code>, import only the node 
     *   itself, as explained above. This has no effect on nodes that cannot 
     *   have any children, and on <code>Attr</code>, and 
     *   <code>EntityReference</code> nodes.
     * @return The imported node that belongs to this <code>Document</code>.
     * @exception DOMException
     *   NOT_SUPPORTED_ERR: Raised if the type of node being imported is not 
     *   supported.
     *   <br>INVALID_CHARACTER_ERR: Raised if one the imported names contain 
     *   an illegal character. This may happen when importing an XML 1.1  
     *   element into an XML 1.0 document, for instance.
     * @since DOM Level 2
     * @see org.w3c.dom.Document#importNode(org.w3c.dom.Node, boolean)
     */
    public Node importNode(final Node importedNode, final boolean deep) 
    		throws DOMException {
        
        switch (importedNode.getNodeType()) {
        	
        	case ELEMENT_NODE:
        	    break;
        	    
        	default:
        	    throw new DOMException(
        	            DOMException.NOT_SUPPORTED_ERR,
        	            "This nodeType[" + importedNode.getNodeType() 
        	            + "] is not supported.");
        }
        // TODO Auto-generated method stub
        return null;
    }

    /**
     * Creates an element of the given qualified name and namespace URI.
     * <br>Per , applications must use the value null as the namespaceURI 
     * parameter for methods if they wish to have no namespace.
     * 
     * @param namespaceURI The namespace URI of the element to create.
     * @param qualifiedName The qualified name of the element type to 
     *   instantiate.
     * @return A new <code>Element</code> object with the following 
     *   attributes:
     * <table border='1'>
     * <tr>
     * <th>Attribute</th>
     * <th>Value</th>
     * </tr>
     * <tr>
     * <td valign='top' rowspan='1' colspan='1'><code>Node.nodeName</code></td>
     * <td valign='top' rowspan='1' colspan='1'>
     *   <code>qualifiedName</code></td>
     * </tr>
     * <tr>
     * <td valign='top' rowspan='1' colspan='1'><code>Node.namespaceURI</code>
     * </td><td valign='top' rowspan='1' colspan='1'>
     *   <code>namespaceURI</code></td>
     * </tr>
     * <tr>
     * <td valign='top' rowspan='1' colspan='1'><code>Node.prefix</code></td>
     * <td valign='top' rowspan='1' colspan='1'>prefix, extracted 
     *   from <code>qualifiedName</code>, or <code>null</code> if there is 
     *   no prefix</td>
     * </tr>
     * <tr>
     * <td valign='top' rowspan='1' colspan='1'><code>Node.localName</code></td>
     * <td valign='top' rowspan='1' colspan='1'>local name, extracted from 
     *   <code>qualifiedName</code></td>
     * </tr>
     * <tr>
     * <td valign='top' rowspan='1' colspan='1'><code>Element.tagName</code>
     * </td><td valign='top' rowspan='1' colspan='1'>
     *   <code>qualifiedName</code></td>
     * </tr>
     * </table>
     * @exception DOMException
     *   INVALID_CHARACTER_ERR: Raised if the specified qualified name 
     *   contains an illegal character, per the XML 1.0 specification .
     *   <br>NAMESPACE_ERR: Raised if the <code>qualifiedName</code> is 
     *   malformed per the Namespaces in XML specification, if the 
     *   <code>qualifiedName</code> has a prefix and the 
     *   <code>namespaceURI</code> is <code>null</code>, or if the 
     *   <code>qualifiedName</code> has a prefix that is "xml" and the 
     *   <code>namespaceURI</code> is different from "
     *   http://www.w3.org/XML/1998/namespace" .
     *   <br>NOT_SUPPORTED_ERR: Always thrown if the current document does not 
     *   support the <code>"XML"</code> feature, since namespaces were 
     *   defined by XML.
     * @since DOM Level 2
     * @see org.w3c.dom.Document#createElementNS(
     * 		java.lang.String, java.lang.String)
     */
    public Element createElementNS(final String namespaceURI, 
                                   final String qualifiedName)
            throws DOMException {
        
        return new ElementNSImpl(this, namespaceURI, qualifiedName);
    }

    /**
     * Creates an attribute of the given qualified name and namespace URI.
     * <br>Per , applications must use the value null as the namespaceURI 
     * parameter for methods if they wish to have no namespace.
     * 
     * @param namespaceURI The namespace URI of the attribute to create.
     * @param qualifiedName The qualified name of the attribute to 
     *   instantiate.
     * @return A new <code>Attr</code> object with the following attributes:
     * <table border='1'>
     * <tr>
     * <th>
     *   Attribute</th>
     * <th>Value</th>
     * </tr>
     * <tr>
     * <td valign='top' rowspan='1' colspan='1'><code>Node.nodeName</code></td>
     * <td valign='top' rowspan='1' colspan='1'>qualifiedName</td>
     * </tr>
     * <tr>
     * <td valign='top' rowspan='1' colspan='1'>
     *   <code>Node.namespaceURI</code></td>
     * <td valign='top' rowspan='1' colspan='1'><code>namespaceURI</code></td>
     * </tr>
     * <tr>
     * <td valign='top' rowspan='1' colspan='1'>
     *   <code>Node.prefix</code></td>
     * <td valign='top' rowspan='1' colspan='1'>prefix, extracted from 
     *   <code>qualifiedName</code>, or <code>null</code> if there is no 
     *   prefix</td>
     * </tr>
     * <tr>
     * <td valign='top' rowspan='1' colspan='1'><code>Node.localName</code></td>
     * <td valign='top' rowspan='1' colspan='1'>local name, extracted from 
     *   <code>qualifiedName</code></td>
     * </tr>
     * <tr>
     * <td valign='top' rowspan='1' colspan='1'><code>Attr.name</code></td>
     * <td valign='top' rowspan='1' colspan='1'>
     *   <code>qualifiedName</code></td>
     * </tr>
     * <tr>
     * <td valign='top' rowspan='1' colspan='1'><code>Node.nodeValue</code></td>
     * <td valign='top' rowspan='1' colspan='1'>the empty 
     *   string</td>
     * </tr>
     * </table>
     * @exception DOMException
     *   INVALID_CHARACTER_ERR: Raised if the specified qualified name 
     *   contains an illegal character, per the XML 1.0 specification .
     *   <br>NAMESPACE_ERR: Raised if the <code>qualifiedName</code> is 
     *   malformed per the Namespaces in XML specification, if the 
     *   <code>qualifiedName</code> has a prefix and the 
     *   <code>namespaceURI</code> is <code>null</code>, if the 
     *   <code>qualifiedName</code> has a prefix that is "xml" and the 
     *   <code>namespaceURI</code> is different from "
     *   http://www.w3.org/XML/1998/namespace", or if the 
     *   <code>qualifiedName</code>, or its prefix, is "xmlns" and the 
     *   <code>namespaceURI</code> is different from "
     *   http://www.w3.org/2000/xmlns/".
     *   <br>NOT_SUPPORTED_ERR: Always thrown if the current document does not 
     *   support the <code>"XML"</code> feature, since namespaces were 
     *   defined by XML.
     * @since DOM Level 2
     * @see org.w3c.dom.Document#createAttributeNS(
     * 		java.lang.String, java.lang.String)
     */
    public Attr createAttributeNS(final String namespaceURI, 
                                  final String qualifiedName)
            throws DOMException {

        return new AttrNSImpl(this, namespaceURI, qualifiedName);
    }

    /**
     * Returns a <code>NodeList</code> of all the <code>Elements</code> with a 
     * given local name and namespace URI in document order.
     * 
     * @param namespaceURI The namespace URI of the elements to match on. The 
     *   special value "*" matches all namespaces.
     * @param localName The local name of the elements to match on. The 
     *   special value "*" matches all local names.
     * @return A new <code>NodeList</code> object containing all the matched 
     *   <code>Elements</code>.
     * @since DOM Level 2
     * @see org.w3c.dom.Document#getElementsByTagNameNS(
     * 		java.lang.String, java.lang.String)
     */
    public NodeList getElementsByTagNameNS(final String namespaceURI, 
                                           final String localName) {
        // TODO Auto-generated method stub
        return null;
    }

    /**
     * Returns the <code>Element</code> whose <code>ID</code> is given by 
     * <code>elementId</code>. If no such element exists, returns 
     * <code>null</code>. Behavior is not defined if more than one element 
     * has this <code>ID</code>. The DOM implementation must have 
     * information that says which attributes are of type ID. Attributes 
     * with the name "ID" are not of type ID unless so defined. 
     * Implementations that do not know whether attributes are of type ID or 
     * not are expected to return <code>null</code>. 
     * 
     * @param elementId The unique <code>id</code> value for an element.
     * @return The matching element.
     * @since DOM Level 2
     * @see org.w3c.dom.Document#getElementById(java.lang.String)
     */
    public Element getElementById(final String elementId) {
        // TODO Auto-generated method stub
        return null;
    }

    /**
     * An attribute specifying the actual encoding of this document. This is 
     * <code>null</code> otherwise.
     * <br> This attribute represents the property [character encoding scheme] 
     * defined in . 
     * 
     * @return ---
     * @since DOM Level 3
     * @see org.w3c.dom.Document#getActualEncoding()
     */
    public String getActualEncoding() {
        // TODO Auto-generated method stub
        return null;
    }

    /**
     * An attribute specifying the actual encoding of this document. This is 
     * <code>null</code> otherwise.
     * <br> This attribute represents the property [character encoding scheme] 
     * defined in .
     * 
     * @param actualEncoding --- 
     * @since DOM Level 3
     * @see org.w3c.dom.Document#setActualEncoding(java.lang.String)
     */
    public void setActualEncoding(final String actualEncoding) {
        // TODO Auto-generated method stub

    }

    /**
     * An attribute specifying, as part of the XML declaration, the encoding 
     * of this document. This is <code>null</code> when unspecified.
     * 
     * @return ---
     * @since DOM Level 3
     * @see org.w3c.dom.Document#getEncoding()
     */
    public String getEncoding() {
        // TODO Auto-generated method stub
        return null;
    }

    /**
     * An attribute specifying, as part of the XML declaration, the encoding 
     * of this document. This is <code>null</code> when unspecified.
     * 
     * @param encoding ---
     * @since DOM Level 3
     * @see org.w3c.dom.Document#setEncoding(java.lang.String)
     */
    public void setEncoding(final String encoding) {
        // TODO Auto-generated method stub

    }

    /**
     * An attribute specifying, as part of the XML declaration, whether this 
     * document is standalone.
     * <br> This attribute represents the property [standalone] defined in .
     * 
     * @return --- 
     * @since DOM Level 3
     * @see org.w3c.dom.Document#getStandalone()
     */
    public boolean getStandalone() {
        return this.standalone;
    }

    /**
     * An attribute specifying, as part of the XML declaration, whether this 
     * document is standalone.
     * <br> This attribute represents the property [standalone] defined in .
     * 
     * @param standaloneIn --- 
     * @since DOM Level 3
     * @see org.w3c.dom.Document#setStandalone(boolean)
     */
    public void setStandalone(final boolean standaloneIn) {
        this.standalone = standaloneIn;
    }

    /**
     * An attribute specifying, as part of the XML declaration, the version 
     * number of this document. This is <code>null</code> when unspecified.
     * <br> This attribute represents the property [version] defined in .
     * 
     * @return ---
     * @since DOM Level 3
     * @see org.w3c.dom.Document#getVersion()
     */
    public String getVersion() {
        return this.version;
    }

    /**
     * An attribute specifying, as part of the XML declaration, the version 
     * number of this document. This is <code>null</code> when unspecified.
     * <br> This attribute represents the property [version] defined in .
     * 
     * @param versionIn --- 
     * @exception DOMException
     *   NOT_SUPPORTED_ERR: Raised if the version is set to a value that is 
     *   not supported by this <code>Document</code>.
     * @since DOM Level 3
     * @see org.w3c.dom.Document#setVersion(java.lang.String)
     */
    public void setVersion(final String versionIn) throws DOMException {
        if (!versionIn.equals("1.0")) {
            throw new DOMException(
                    DOMException.NOT_SUPPORTED_ERR,
                    "This implementation supports only XML 1.0");
        }
        this.version = versionIn;
    }

    /**
     * An attribute specifying whether errors checking is enforced or not. 
     * When set to <code>false</code>, the implementation is free to not 
     * test every possible error case normally defined on DOM operations, 
     * and not raise any <code>DOMException</code>. In case of error, the 
     * behavior is undefined. This attribute is <code>true</code> by 
     * defaults.
     * 
     * @return ---
     * @since DOM Level 3
     * @see org.w3c.dom.Document#getStrictErrorChecking()
     */
    public boolean getStrictErrorChecking() {
        // TODO Auto-generated method stub
        return false;
    }

    /**
     * An attribute specifying whether errors checking is enforced or not. 
     * When set to <code>false</code>, the implementation is free to not 
     * test every possible error case normally defined on DOM operations, 
     * and not raise any <code>DOMException</code>. In case of error, the 
     * behavior is undefined. This attribute is <code>true</code> by 
     * defaults.
     * 
     * @param strictErrorChecking ---
     * @since DOM Level 3
     * @see org.w3c.dom.Document#setStrictErrorChecking(boolean)
     */
    public void setStrictErrorChecking(final boolean strictErrorChecking) {
        // TODO Auto-generated method stub

    }

    /**
     * This attribute allows applications to specify a 
     * <code>DOMErrorHandler</code> to be called in the event that an error 
     * is encountered while performing an operation on a document. Note that 
     * not all methods use this mechanism, see the description of each 
     * method for details.
     * 
     * @return ---
     * @since DOM Level 3
     * @see org.w3c.dom.Document#getErrorHandler()
     */
    public DOMErrorHandler getErrorHandler() {
        // TODO Auto-generated method stub
        return null;
    }

    /**
     * This attribute allows applications to specify a 
     * <code>DOMErrorHandler</code> to be called in the event that an error 
     * is encountered while performing an operation on a document. Note that 
     * not all methods use this mechanism, see the description of each 
     * method for details.
     * 
     * @param errorHandler The error handler.
     * @since DOM Level 3
     * @see org.w3c.dom.Document#setErrorHandler(org.w3c.dom.DOMErrorHandler)
     */
    public void setErrorHandler(final DOMErrorHandler errorHandler) {
        // TODO Auto-generated method stub

    }

    /**
     * The location of the document or <code>null</code> if undefined.
     * <br>Beware that when the <code>Document</code> supports the feature 
     * "HTML" , the href attribute of the HTML BASE element takes precedence 
     * over this attribute.
     * 
     * @return The uri for this document.
     * @since DOM Level 3
     * @see org.w3c.dom.Document#getDocumentURI()
     */
    public String getDocumentURI() {
        // TODO Auto-generated method stub
        return null;
    }

    /**
     * The location of the document or <code>null</code> if undefined.
     * <br>Beware that when the <code>Document</code> supports the feature 
     * "HTML" , the href attribute of the HTML BASE element takes precedence 
     * over this attribute.
     * 
     * @param documentURI The uri for this document.
     * @since DOM Level 3
     * @see org.w3c.dom.Document#setDocumentURI(java.lang.String)
     */
    public void setDocumentURI(final String documentURI) {
        // TODO Auto-generated method stub

    }

    /**
     * Changes the <code>ownerDocument</code> of a node, its children, as well 
     * as the attached attribute nodes if there are any. If the node has a 
     * parent it is first removed from its parent child list. This 
     * effectively allows moving a subtree from one document to another. The 
     * following list describes the specifics for each type of node. 
     * <dl>
     * <dt>
     * ATTRIBUTE_NODE</dt>
     * <dd>The <code>ownerElement</code> attribute is set to 
     * <code>null</code> and the <code>specified</code> flag is set to 
     * <code>true</code> on the adopted <code>Attr</code>. The descendants 
     * of the source <code>Attr</code> are recursively adopted.</dd>
     * <dt>
     * DOCUMENT_FRAGMENT_NODE</dt>
     * <dd>The descendants of the source node are 
     * recursively adopted.</dd>
     * <dt>DOCUMENT_NODE</dt>
     * <dd><code>Document</code> nodes cannot 
     * be adopted.</dd>
     * <dt>DOCUMENT_TYPE_NODE</dt>
     * <dd><code>DocumentType</code> nodes cannot 
     * be adopted.</dd>
     * <dt>ELEMENT_NODE</dt>
     * <dd>Specified attribute nodes of the source 
     * element are adopted, and the generated <code>Attr</code> nodes. 
     * Default attributes are discarded, though if the document being 
     * adopted into defines default attributes for this element name, those 
     * are assigned. The descendants of the source element are recursively 
     * adopted.</dd>
     * <dt>ENTITY_NODE</dt>
     * <dd><code>Entity</code> nodes cannot be adopted.</dd>
     * <dt>
     * ENTITY_REFERENCE_NODE</dt>
     * <dd>Only the <code>EntityReference</code> node 
     * itself is adopted, the descendants are discarded, since the source 
     * and destination documents might have defined the entity differently. 
     * If the document being imported into provides a definition for this 
     * entity name, its value is assigned.</dd>
     * <dt>NOTATION_NODE</dt>
     * <dd><code>Notation</code> 
     * nodes cannot be adopted.</dd>
     * <dt>PROCESSING_INSTRUCTION_NODE, TEXT_NODE, 
     * CDATA_SECTION_NODE, COMMENT_NODE</dt>
     * <dd>These nodes can all be adopted. No 
     * specifics.</dd>
     * </dl> Should this method simply return null when it fails? How 
     * "exceptional" is failure for this method?Stick with raising 
     * exceptions only in exceptional circumstances, return null on failure 
     * (F2F 19 Jun 2000).Can an entity node really be adopted?No, neither 
     * can Notation nodes (Telcon 13 Dec 2000).Does this affect keys and 
     * hashCode's of the adopted subtree nodes?If so, what about 
     * readonly-ness of key and hashCode?if not, would appendChild affect 
     * keys/hashCodes or would it generate exceptions if key's are duplicate?
     * Both keys and hashcodes have been dropped.
     * 
     * @param source The node to move into this document.
     * @return The adopted node, or <code>null</code> if this operation 
     *   fails, such as when the source node comes from a different 
     *   implementation.
     * @exception DOMException
     *   NOT_SUPPORTED_ERR: Raised if the source node is of type 
     *   <code>DOCUMENT</code>, <code>DOCUMENT_TYPE</code>.
     *   <br>NO_MODIFICATION_ALLOWED_ERR: Raised when the source node is 
     *   readonly.
     * @since DOM Level 3
     * @see org.w3c.dom.Document#adoptNode(org.w3c.dom.Node)
     */
    public Node adoptNode(final Node source) throws DOMException {
        throw new DOMException(
                DOMException.NOT_SUPPORTED_ERR,
                "The feature [adoptNode()] is not supported");
    }

    /**
     * This method acts as if the document was going through a save and load 
     * cycle, putting the document in a "normal" form. The actual result 
     * depends on the features being set and governing what operations 
     * actually take place. See <code>setNormalizeFeature</code> for details.
     * <br>Noticeably this method normalizes <code>Text</code> nodes, makes 
     * the document "namespace wellformed", according to the algorithm 
     * described below in pseudo code, by adding missing namespace 
     * declaration attributes and adding or changing namespace prefixes, 
     * updates the replacement tree of <code>EntityReference</code> nodes, 
     * normalizes attribute values, etc.
     * <br>See  for details on how namespace declaration attributes and 
     * prefixes are normalized.Any other name? Joe proposes 
     * normalizeNamespaces.normalizeDocument. (F2F 26 Sep 2001)How specific 
     * should this be? Should we not even specify that this should be done 
     * by walking down the tree?Very. See above.What does this do on 
     * attribute nodes?Doesn't do anything (F2F 1 Aug 2000).How does it work 
     * with entity reference subtree which may be broken?This doesn't affect 
     * entity references which are not visited in this operation (F2F 1 Aug 
     * 2000).Should this really be on Node?Yes, but this only works on 
     * Document, Element, and DocumentFragment. On other types it is a 
     * no-op. (F2F 1 Aug 2000).No. Now that it does much more than simply 
     * fixing namespaces it only makes sense on Document (F2F 26 Sep 2001).
     * What happens with read-only nodes?What/how errors should be reported? 
     * Are there any?Through the error reporter.Should this be optional?No.
     * What happens with regard to mutation events?
     * 
     * @since DOM Level 3
     * @see org.w3c.dom.Document#normalizeDocument()
     */
    public void normalizeDocument() {
        // TODO Auto-generated method stub

    }

    /**
     * Query whether setting a feature to a specific value is supported.
     * <br>The feature name has the same form as a DOM <code>hasFeature</code> 
     * string.
     * @param name The name of the feature to check.
     * @param state The requested state of the feature (<code>true</code> or 
     *   <code>false</code>).
     * @return <code>true</code> if the feature could be successfully set to 
     *   the specified value, or <code>false</code> if the feature is not 
     *   recognized or the requested value is not supported. This does not 
     *   change the current value of the feature itself.
     * @since DOM Level 3
     * @see org.w3c.dom.Document#canSetNormalizationFeature(
     * 		java.lang.String, boolean)
     */
    public boolean canSetNormalizationFeature(final String name, 
                                              final boolean state) {
        return false;
    }

    /**
     * Set the state of a feature.Need to specify the list of features.
     * <br>Feature names are valid XML names. Implementation specific features 
     * (extensions) should choose an implementation specific prefix to avoid 
     * name collisions. The following lists feature names that are 
     * recognized by all implementations. However, it is sometimes possible 
     * for a <code>Document</code> to recognize a feature but not to support 
     * setting its value. The following list of recognized features 
     * indicates the definitions of each feature state, if setting the state 
     * to <code>true</code> or <code>false</code> must be supported or is 
     * optional and, which state is the default one:
     * <dl>
     * <dt>
     * <code>"normalize-characters"</code></dt>
     * <dd>
     * <dl>
     * <dt><code>true</code></dt>
     * <dd>[optional]Perform 
     * the W3C Text Normalization of the characters  in the document. </dd>
     * <dt>
     * <code>false</code></dt>
     * <dd>[required] (default)Do not perform character 
     * normalization.</dd>
     * </dl></dd>
     * <dt><code>"split-cdata-sections"</code></dt>
     * <dd>
     * <dl>
     * <dt><code>true</code></dt>
     * <dd>[
     * required] (default)Split CDATA sections containing the CDATA section 
     * termination marker ']]&gt;'. When a CDATA section is split a warning 
     * is issued.</dd>
     * <dt><code>false</code></dt>
     * <dd>[required]Signal an error if a 
     * <code>CDATASection</code> contains an unrepresentable character.</dd>
     * </dl></dd>
     * <dt>
     * <code>"expand-entity-references"</code></dt>
     * <dd>
     * <dl>
     * <dt><code>true</code></dt>
     * <dd>[optional]
     * Expand <code>EntityReference</code> nodes when normalizing.</dd>
     * <dt>
     * <code>false</code></dt>
     * <dd>[required] (default)Keep all 
     * <code>EntityReference</code> nodes in document.</dd>
     * </dl></dd>
     * <dt>
     * <code>"whitespace-in-element-content"</code></dt>
     * <dd>
     * <dl>
     * <dt><code>true</code></dt>
     * <dd>[required
     * ] (default)Keep all white spaces in the document.</dd>
     * <dt><code>false</code></dt>
     * <dd>[
     * optional]Discard white space in element content while normalizing. 
     * The implementation is expected to use the 
     * <code>isWhitespaceInElementContent</code> flag on <code>Text</code> 
     * nodes to determine if a text node should be written out or not.</dd>
     * </dl></dd>
     * <dt>
     * <code>"discard-default-content"</code></dt>
     * <dd>
     * <dl>
     * <dt><code>true</code></dt>
     * <dd>[required] (
     * default)Use whatever information available to the implementation 
     * (i.e. XML schema, DTD, the <code>specified</code> flag on 
     * <code>Attr</code> nodes, and so on) to decide what attributes and 
     * content should be discarded or not. Note that the 
     * <code>specified</code> flag on <code>Attr</code> nodes in itself is 
     * not always reliable, it is only reliable when it is set to 
     * <code>false</code> since the only case where it can be set to 
     * <code>false</code> is if the attribute was created by a Level 1 
     * implementation.How does exactly work? What's the comment about level 
     * 1 implementations?</dd>
     * <dt><code>false</code></dt>
     * <dd>[required]Keep all attributes and 
     * all content.</dd>
     * </dl></dd>
     * <dt><code>"format-canonical"</code></dt>
     * <dd>
     * <dl>
     * <dt><code>true</code></dt>
     * <dd>[optional]
     * Canonicalize the document according to the rules specified in . 
     * Setting this feature to true sets the feature "format-pretty-print" 
     * to false.</dd>
     * <dt><code>false</code></dt>
     * <dd>[required] (default)Do not canonicalize 
     * the document.</dd>
     * </dl></dd>
     * <dt><code>"format-pretty-print"</code></dt>
     * <dd>
     * <dl>
     * <dt><code>true</code></dt>
     * <dd>[
     * optional]Format the document by adding whitespace to produce a 
     * pretty-printed, indented, human-readable form. The exact form of the 
     * transformations is not specified by this specification. Setting this 
     * feature to true sets the feature "format-canonical" to false.</dd>
     * <dt>
     * <code>false</code></dt>
     * <dd>[required] (default)Do not pretty-print the 
     * document.</dd>
     * </dl></dd>
     * <dt><code>"namespace-declarations"</code></dt>
     * <dd>
     * <dl>
     * <dt><code>true</code></dt>
     * <dd>[
     * required] (default)Include namespace declaration attributes, 
     * specified or defaulted from the schema or the DTD, in the document. 
     * See also the section Declaring Namespaces in .</dd>
     * <dt><code>false</code></dt>
     * <dd>[
     * optional]Discard all namespace declaration attributes. The Namespace 
     * prefixes are retained even if this feature is set to 
     * <code>false</code>.</dd>
     * </dl></dd>
     * <dt><code>"validation"</code></dt>
     * <dd>
     * <dl>
     * <dt><code>true</code></dt>
     * <dd>[optional
     * ]Use the abstract schema to validate the document as it is being 
     * normalized. If validation errors are found the error handler is 
     * notified. Setting it to <code>true</code> also forces the 
     * <code>external-general-entities</code> and 
     * <code>external-parameter-entities</code> features to be 
     * <code>true</code>.) Also note that the <code>validate-if-schema</code>
     *  feature alters the validation behavior when this feature is set to 
     * <code>true</code>.</dd>
     * <dt><code>false</code></dt>
     * <dd>[required] (default)Do not report 
     * validation errors.</dd>
     * </dl></dd>
     * <dt><code>"external-parameter-entities"</code></dt>
     * <dd>
     * <dl>
     * <dt>
     * <code>true</code></dt>
     * <dd>[required]Load external parameter entities.Doesn't 
     * really apply, does it? What does including them mean? Also, false 
     * can't be the default and be optional at the same time.</dd>
     * <dt>
     * <code>false</code></dt>
     * <dd>[optional] (default)Do not load external parameter 
     * entities.</dd>
     * </dl></dd>
     * <dt><code>"external-general-entities"</code></dt>
     * <dd>
     * <dl>
     * <dt><code>true</code></dt>
     * <dd>[
     * required] (default)Include all external general (text) entities.
     * Doesn't really apply, does it? What does including them mean?</dd>
     * <dt>
     * <code>false</code></dt>
     * <dd>[optional]Do not include external general entities.</dd>
     * </dl></dd>
     * <dt>
     * <code>"external-dtd-subset"</code></dt>
     * <dd>
     * <dl>
     * <dt><code>true</code></dt>
     * <dd>[required] (default
     * )Load the external DTD subset and also all external parameter 
     * entities.Doesn't really apply, does it? What does loading mean here?</dd>
     * <dt>
     * <code>false</code></dt>
     * <dd>[optional]Do not load the external DTD subset nor 
     * external parameter entities.</dd>
     * </dl></dd>
     * <dt><code>"validate-if-schema"</code></dt>
     * <dd>
     * <dl>
     * <dt>
     * <code>true</code></dt>
     * <dd>[optional]When both this feature and validation are 
     * <code>true</code>, enable validation only if the document being 
     * processed has a schema (i.e. XML schema, DTD, any other type of 
     * schema, note that this is unrelated to the abstract schema 
     * specification). Documents without schemas are normalized without 
     * validation.How does that interact with the notion of active AS?</dd>
     * <dt>
     * <code>false</code></dt>
     * <dd>[required] (default)The validation feature alone 
     * controls whether the document is checked for validity. Documents 
     * without a schemas are not valid.</dd>
     * </dl></dd>
     * <dt><code>"validate-against-dtd"</code></dt>
     * <dd>
     * <dl>
     * <dt>
     * <code>true</code></dt>
     * <dd>[optional]Prefer validation against the DTD over any 
     * other schema used with the document.How does that interact with the 
     * notion of active AS?</dd>
     * <dt><code>false</code></dt>
     * <dd>[required] (default)Let the 
     * implementation decide what to validate against if multiple types of 
     * schemas are in use.</dd>
     * </dl></dd>
     * <dt><code>"datatype-normalization"</code></dt>
     * <dd>
     * <dl>
     * <dt>
     * <code>true</code></dt>
     * <dd>[required]Let the (non-DTD) validation process do 
     * its datatype normalization that is defined in the used schema 
     * language.We should define "datatype normalization".</dd>
     * <dt><code>false</code></dt>
     * <dd>[
     * required] (default)Disable datatype normalization. The XML 1.0 
     * attribute value normalization always occurs though.</dd>
     * </dl></dd>
     * <dt>
     * <code>"create-entity-ref-nodes"</code></dt>
     * <dd>
     * <dl>
     * <dt><code>true</code></dt>
     * <dd>[required] (
     * default)Create <code>EntityReference</code> nodes in the document. It 
     * will also set <code>create-entity-nodes</code> to be <code>true</code>
     * .How does that interact with expand-entity-references? ALH suggests 
     * consolidating the two to a single feature called "entity-references" 
     * that is used both for load and save.</dd>
     * <dt><code>false</code></dt>
     * <dd>[optional]Omit 
     * all <code>EntityReference</code> nodes from the document, putting the 
     * entity expansions directly in their place. <code>Text</code> nodes 
     * are into "normal" form. <code>EntityReference</code> nodes to 
     * non-defined entities are still created in the document.</dd>
     * </dl></dd>
     * <dt>
     * <code>"create-entity-nodes"</code></dt>
     * <dd>
     * <dl>
     * <dt><code>true</code></dt>
     * <dd>[required] (default
     * )Create <code>Entity</code> nodes in the document.How does that 
     * interact with expand-entity-references? ALH suggests renaming this 
     * one "entity-nodes", or simply "entities" for consistency.</dd>
     * <dt>
     * <code>false</code></dt>
     * <dd>[optional]Omit all <code>entity</code> nodes from 
     * the document. It also sets <code>create-entity-ref-nodes</code> to 
     * <code>false</code>.</dd>
     * </dl></dd>
     * <dt><code>"create-cdata-nodes"</code></dt>
     * <dd>
     * <dl>
     * <dt><code>true</code></dt>
     * <dd>[
     * required] (default)Keep <code>CDATASection</code> nodes the document.
     * Name does not work really well in this case. ALH suggests renaming 
     * this to "cdata-sections". It works for both load and save.</dd>
     * <dt>
     * <code>false</code></dt>
     * <dd>[optional]Transform <code>CDATASection</code> nodes 
     * in the document into <code>Text</code> nodes. The new 
     * <code>Text</code> node is then combined with any adjacent 
     * <code>Text</code> node.</dd>
     * </dl></dd>
     * <dt><code>"comments"</code></dt>
     * <dd>
     * <dl>
     * <dt><code>true</code></dt>
     * <dd>[
     * required] (default)Keep <code>Comment</code> nodes in the document.</dd>
     * <dt>
     * <code>false</code></dt>
     * <dd>[required]Discard <code>Comment</code> nodes in the 
     * Document.</dd>
     * </dl></dd>
     * <dt><code>"load-as-infoset"</code></dt>
     * <dd>
     * <dl>
     * <dt><code>true</code></dt>
     * <dd>[optional]
     * Only keep in the document the information defined in the XML 
     * Information Set .This forces the following features to 
     * <code>false</code>: <code>namespace-declarations</code>, 
     * <code>validate-if-schema</code>, <code>create-entity-ref-nodes</code>
     * , <code>create-entity-nodes</code>, <code>create-cdata-nodes</code>.
     * This forces the following features to <code>true</code>: 
     * <code>datatype-normalization</code>, 
     * <code>whitespace-in-element-content</code>, <code>comments</code>.
     * Other features are not changed unless explicity specified in the 
     * description of the features. Note that querying this feature with 
     * <code>getFeature</code> returns <code>true</code> only if the 
     * individual features specified above are appropriately set.Name 
     * doesn't work well here. ALH suggests renaming this to 
     * limit-to-infoset or match-infoset, something like that.</dd>
     * <dt>
     * <code>false</code></dt>
     * <dd>Setting <code>load-as-infoset</code> to 
     * <code>false</code> has no effect.Shouldn't we change this to setting 
     * the relevant options back to their default value?</dd>
     * </dl></dd>
     * </dl>
     * 
     * @param name The name of the feature to set.
     * @param state The requested state of the feature (<code>true</code> or 
     *   <code>false</code>).
     * @exception DOMException
     *   NOT_SUPPORTED_ERR: Raised when the feature name is recognized but the 
     *   requested value cannot be set.
     *   <br>NOT_FOUND_ERR: Raised when the feature name is not recognized.
     * @since DOM Level 3
     * @see org.w3c.dom.Document#setNormalizationFeature(
     * 		java.lang.String, boolean)
     */
    public void setNormalizationFeature(final String name, final boolean state)
            throws DOMException {
        
        throw new DOMException(
                DOMException.NOT_SUPPORTED_ERR,
                "Feature [setNormalizationFeature] is not supported.");
    }

    /**
     * Look up the value of a feature.
     * <br>The feature name has the same form as a DOM <code>hasFeature</code> 
     * string. The recognized features are the same as the ones defined for 
     * <code>setNormalizationFeature</code>.
     * @param name The name of the feature to look up.
     * @return The current state of the feature (<code>true</code> or 
     *   <code>false</code>).
     * @exception DOMException
     *   NOT_FOUND_ERR: Raised when the feature name is not recognized.
     * @since DOM Level 3
     * @see org.w3c.dom.Document#getNormalizationFeature(java.lang.String)
     */
    public boolean getNormalizationFeature(final String name) 
    		throws DOMException {
        return false;
    }

    /**
     * Rename an existing node. When possible this simply changes the name of 
     * the given node, otherwise this creates a new node with the specified 
     * name and replaces the existing node with the new node as described 
     * below. This only applies to nodes of type <code>ELEMENT_NODE</code> 
     * and <code>ATTRIBUTE_NODE</code>.
     * <br>When a new node is created, the following operations are performed: 
     * the new node is created, any registered event listener is registered 
     * on the new node, any user data attached to the old node is removed 
     * from that node, the old node is removed from its parent if it has 
     * one, the children are moved to the new node, if the renamed node is 
     * an <code>Element</code> its attributes are moved to the new node, the 
     * new node is inserted at the position the old node used to have in its 
     * parent's child nodes list if it has one, the user data that was 
     * attached to the old node is attach to the new node, the user data 
     * event <code>NODE_RENAMED</code> is fired.
     * <br>When the node being renamed is an <code>Attr</code> that is 
     * attached to an <code>Element</code>, the node is first removed from 
     * the <code>Element</code> attributes map. Then, once renamed, either 
     * by modifying the existing node or creating a new one as described 
     * above, it is put back.
     * <br>In addition, when the implementation supports the feature 
     * "MutationEvents", each mutation operation involved in this method 
     * fires the appropriate event, and in the end the event 
     * <code>ElementNameChanged</code> or <code>AttributeNameChanged</code> 
     * is fired.Should this throw a HIERARCHY_REQUEST_ERR?
     * 
     * @param n The node to rename.
     * @param namespaceURI The new namespaceURI.
     * @param name The new qualified name.
     * @return The renamed node. This is either the specified node or the new 
     *   node that was created to replace the specified node.
     * @exception DOMException
     *   NOT_SUPPORTED_ERR: Raised when the type of the specified node is 
     *   neither <code>ELEMENT_NODE</code> nor <code>ATTRIBUTE_NODE</code>.
     * @since DOM Level 3
     * @see org.w3c.dom.Document#renameNode(
     * 		org.w3c.dom.Node, java.lang.String, java.lang.String)
     */
    public Node renameNode(final Node n, 
                           final String namespaceURI, 
                           final String name) throws DOMException {
        // TODO Auto-generated method stub
        return null;
    }
    
    /**
     *  The configuration used when <code>Document.normalizeDocument()</code> 
     * is invoked. 
     * 
     * @return ..
     * @since DOM Level 3
     * @see org.w3c.dom.Document#getDomConfig()
     */
    public DOMConfiguration getDomConfig() {
        // TODO Auto-generated method stub
        return null;
    }
    
    /**
     * An attribute specifying the encoding used for this document at the time 
     * of the parsing. This is <code>null</code> when it is not known, such 
     * as when the <code>Document</code> was created in memory.
     * 
     * @return ..
     * @since DOM Level 3
     * @see org.w3c.dom.Document#getInputEncoding()
     */
    public String getInputEncoding() {
        // TODO Auto-generated method stub
        return null;
    }
    
    /**
     * An attribute specifying, as part of the <a 
     * href='http://www.w3.org/TR/2004/REC-xml-20040204#NT-XMLDecl'
     * >XML declaration</a>, the encoding of this document. This is 
     * <code>null</code> when unspecified or when it is not known, such as 
     * when the <code>Document</code> was created in memory.
     * 
     * @return ..
     * @since DOM Level 3
     * @see org.w3c.dom.Document#getXmlEncoding()
     */
    public String getXmlEncoding() {
        // TODO Auto-generated method stub
        return null;
    }
    
    /**
     * An attribute specifying, as part of the <a 
     * href='http://www.w3.org/TR/2004/REC-xml-20040204#NT-XMLDecl'
     * >XML declaration</a>, whether this document is standalone. This is 
     * <code>false</code> when unspecified.
     * <p ><b>Note:</b>  No verification is done on the value when setting this 
     * attribute. Applications should use <code>Document.normalizeDocument()
     * </code> with the "validate" parameter to verify if the value matches the 
     * <a href='http://www.w3.org/TR/2004/REC-xml-20040204#sec-rmd'>validity 
     * constraint for standalone document declaration</a> as defined in 
     * [<a href='http://www.w3.org/TR/2004/REC-xml-20040204'>XML 1.0</a>].
     * 
     * @return .. 
     * @since DOM Level 3
     * @see org.w3c.dom.Document#getXmlStandalone()
     */
    public boolean getXmlStandalone() {
        // TODO Auto-generated method stub
        return false;
    }
    
    /**
     * An attribute specifying, as part of the <a 
     * href='http://www.w3.org/TR/2004/REC-xml-20040204#NT-XMLDecl'
     * >XML declaration</a>, the version number of this document. If there is 
     * no declaration and if 
     * this document supports the "XML" feature, the value is 
     * <code>"1.0"</code>. If this document does not support the "XML" 
     * feature, the value is always <code>null</code>. Changing this 
     * attribute will affect methods that check for invalid characters in 
     * XML names. Application should invoke 
     * <code>Document.normalizeDocument()</code> in order to check for 
     * invalid characters in the <code>Node</code>s that are already part of 
     * this <code>Document</code>. 
     * <br> DOM applications may use the 
     * <code>DOMImplementation.hasFeature(feature, version)</code> method 
     * with parameter values "XMLVersion" and "1.0" (respectively) to 
     * determine if an implementation supports [<a 
     * href='http://www.w3.org/TR/2004/REC-xml-20040204'>XML 1.0</a>]. DOM 
     * applications may use the same method with parameter values 
     * "XMLVersion" and "1.1" (respectively) to determine if an 
     * implementation supports [<a 
     * href='http://www.w3.org/TR/2004/REC-xml11-20040204/'>XML 1.1</a>]. In 
     * both 
     * cases, in order to support XML, an implementation must also support 
     * the "XML" feature defined in this specification. <code>Document</code>
     *  objects supporting a version of the "XMLVersion" feature must not 
     * raise a <code>NOT_SUPPORTED_ERR</code> exception for the same version 
     * number when using <code>Document.xmlVersion</code>.
     * 
     * @return .. 
     * @since DOM Level 3
     * @see org.w3c.dom.Document#getXmlVersion()
     */
    public String getXmlVersion() {
        // TODO Auto-generated method stub
        return null;
    }
    
    /**
     * An attribute specifying, as part of the <a 
     * href='http://www.w3.org/TR/2004/REC-xml-20040204#NT-XMLDecl'
     * >XML declaration</a>, whether this document is standalone. This is 
     * <code>false</code> when unspecified.
     * <p ><b>Note:</b>  No verification is done on the value when setting 
     * this attribute. Applications should use 
     * <code>Document.normalizeDocument()</code> with the "validate" parameter 
     * to verify if the value matches the <a 
     * href='http://www.w3.org/TR/2004/REC-xml-20040204#sec-rmd'>validity 
     * constraint for standalone document declaration</a> as defined in 
     * [<a href='http://www.w3.org/TR/2004/REC-xml-20040204'>XML 1.0</a>].
     * 
     * @param xmlStandalone .. 
     * @exception DOMException
     *    NOT_SUPPORTED_ERR: Raised if this document does not support the 
     *   "XML" feature. 
     * @since DOM Level 3
     * @see org.w3c.dom.Document#setXmlStandalone(boolean)
     */
    public void setXmlStandalone(final boolean xmlStandalone) 
    		throws DOMException {
        // TODO Auto-generated method stub

    }
    
    /**
     *  An attribute specifying, as part of the <a 
     * href='http://www.w3.org/TR/2004/REC-xml-20040204#NT-XMLDecl'
     * >XML declaration</a>, the version number of this document. If there is 
     * no declaration and if 
     * this document supports the "XML" feature, the value is 
     * <code>"1.0"</code>. If this document does not support the "XML" 
     * feature, the value is always <code>null</code>. Changing this 
     * attribute will affect methods that check for invalid characters in 
     * XML names. Application should invoke 
     * <code>Document.normalizeDocument()</code> in order to check for 
     * invalid characters in the <code>Node</code>s that are already part of 
     * this <code>Document</code>. 
     * <br> DOM applications may use the 
     * <code>DOMImplementation.hasFeature(feature, version)</code> method 
     * with parameter values "XMLVersion" and "1.0" (respectively) to 
     * determine if an implementation supports [<a 
     * href='http://www.w3.org/TR/2004/REC-xml-20040204'>XML 1.0</a>]. DOM 
     * applications may use the same method with parameter values 
     * "XMLVersion" and "1.1" (respectively) to determine if an 
     * implementation supports [<a 
     * href='http://www.w3.org/TR/2004/REC-xml11-20040204/'>XML 1.1</a>]. 
     * In both 
     * cases, in order to support XML, an implementation must also support 
     * the "XML" feature defined in this specification. <code>Document</code>
     *  objects supporting a version of the "XMLVersion" feature must not 
     * raise a <code>NOT_SUPPORTED_ERR</code> exception for the same version 
     * number when using <code>Document.xmlVersion</code>.
     * 
     * @param xmlVersion ... 
     * @exception DOMException
     *    NOT_SUPPORTED_ERR: Raised if the version is set to a value that is 
     *   not supported by this <code>Document</code> or if this document 
     *   does not support the "XML" feature. 
     * @since DOM Level 3
     * @see org.w3c.dom.Document#setXmlVersion(java.lang.String)
     */
    public void setXmlVersion(final String xmlVersion) throws DOMException {
        // TODO Auto-generated method stub

    }
    //
    // Methods from de.xplib.nexd.xml.dom.AbstractParentNode
    //
    
    /**
     * <Some description here>
     * 
     * @param nodeIn
     * @throws DOMException
     * @see de.xplib.nexd.xml.dom.AbstractParentNode#acceptNode(
     * 		org.w3c.dom.Node)
     */
    protected int acceptNode(final Node nodeIn) throws DOMException {
        
        if (nodeIn.getOwnerDocument() != this) {
            throw new DOMException(
                    DOMException.WRONG_DOCUMENT_ERR,
                    "The node is from another Document.");
        } else if (nodeIn instanceof ElementImpl) {
            if (this.documentElement != null) {
                throw new DOMException(
                        DOMException.HIERARCHY_REQUEST_ERR,
                        "There is allready a document element.");
            } else {
                this.documentElement = (ElementImpl) nodeIn;
            }
        } else if (nodeIn instanceof DocumentTypeImpl) {
            if (this.doctype != null) {
                throw new DOMException(
                        DOMException.HIERARCHY_REQUEST_ERR,
                        "There is allready a doctype.");
            } else {
                this.doctype = (DocumentTypeImpl) nodeIn;
            }
            return ADD_TOP;
        } else if (nodeIn instanceof AttrImpl 
                || nodeIn instanceof CDATASectionImpl
                || nodeIn instanceof EntityReferenceImpl
                || nodeIn instanceof TextImpl) {
            
            throw new DOMException(
                    DOMException.HIERARCHY_REQUEST_ERR,
                    "Nodes of this type are not allowed.");
        }
        return ADD_BOTTOM;
    }

}
